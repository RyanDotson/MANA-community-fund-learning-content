import { DiffPacket } from './internal/types';
export { IEntity } from './internal/applyPatch';
export interface ISimplifiedNode {
    tag: string;
    children: ISimplifiedNode[];
    attrs: {
        [name: string]: string | number[] | object | boolean | number;
    };
}
export interface Identity {
    getUserPublicKey(): Promise<string>;
}
export declare type LandDataVersion0 = {
    version: 0;
    name: string;
    description: string;
    ipns: string;
};
export interface ILand {
    x: number;
    y: number;
    hash: string;
    owner: string;
    landData: LandDataVersion0;
    scene?: any;
    baseUrl: string;
    html?: string;
}
export interface ParcelIdentity {
    getParcel(): Promise<{
        x: number;
        y: number;
        land: ILand;
    }>;
}
export interface EntityController {
    getOwnAttributes(): Promise<{
        [key: string]: any;
    }>;
    render(element: ISimplifiedNode | DiffPacket): Promise<void>;
    subscribe(event: string): Promise<void>;
    unsubscribe(event: string): Promise<void>;
    onSubscribedEvent(fn: any): void;
    setEntityAttributes(entityId: string, attributes: {
        [key: string]: any;
    }): Promise<void>;
    getEntityAttribute(entityId: string, attribute: string): Promise<string>;
    getOwnAttributes(): Promise<{
        [key: string]: string;
    }>;
}
export interface EthereumController {
    /**
     * Use ServiceLocator contract to resolve an contract namespace
     * @param  {string} [namespace] - namespace to resolve
     * @return {string} - Address of the contract
     */
    resolveAddress(namespace: string): Promise<string>;
    /**
     * Check a ERC721 contract for ownership status
     * @param  {string} [ownerAddress] - namespace to resolve
     * @param  {string} [tokenId] - tokenId in the registry contract
     * @param  {string} [registryAddress] - address of the ERC721 DAR.
     * @return {string} - true if provided address is the owner of the asset.
     */
    isOwnerOfCollectible(ownerAddress: string, tokenId: string, registryAddress: string): Promise<boolean>;
    /**
     * Executes a order from the marketplace contract
     * @param  {string} [assetId] - NFT asset id.
     * @param  {string} [amount] - Exact amount of the order.
     * @param  {string} [marketplaceAddress] - Marketplace contract address.
     */
    buyCollectible(assetId: string, amount: string, marketplaceAddress: string): Promise<any>;
    /**
     * Requires a generic payment in ETH or ERC20.
     * @param  {string} [toAddress] - NFT asset id.
     * @param  {string} [amount] - Exact amount of the order.
     * @param  {string} [currency] - ETH or ERC20 supported token symbol
     */
    requirePayment(toAddress: string, amount: string, currency: string): Promise<any>;
}
export interface SoundOptions {
    volume: number;
    loop: boolean;
}
export interface CharactersIdentity {
    getMyPositionInParcel(): Promise<{
        position: {
            x: number;
            y: number;
            z: number;
        };
    }>;
}
export interface SoundController {
    playSound(src: string, options?: {
        volume?: number;
        entity?: string;
        loop?: boolean;
    }): Promise<void>;
}
export declare namespace EventNames {
    const ReplaceWholeTreeException = "ReplaceWholeTreeException";
    const setAttributes = "setAttributes";
}
export declare type Vector3Component = {
    x: number;
    y: number;
    z: number;
};
export declare type Vector2Component = {
    x: number;
    y: number;
};
export declare type MaterialComponent = {
    color?: string;
    alphaTest?: number;
    depthTest?: boolean;
    opacity?: number;
    side?: 'back' | 'front' | 'double';
    transparent?: boolean;
    vertexColors?: boolean;
    visible?: boolean;
    ambientOcclusionMap?: string;
    ambientOcclusionIntensity?: number;
    metalness?: number;
    roughness?: number;
    src?: string;
    repeat?: Vector2Component;
    offset?: Vector2Component;
    wireframe?: boolean;
};
export declare type SoundComponent = {
    autoplay?: boolean;
    distanceModel?: 'linear' | 'inverse' | 'exponential';
    loop?: boolean;
    maxDistance?: number;
    on?: string;
    poolSize?: number;
    positional?: boolean;
    refDistance?: number;
    rolloffFactor?: number;
    src: string;
    volume?: number;
};
export declare type TransitionValue = {
    duration: number;
    timing?: string;
    delay?: number;
};
export declare type TransitionComponent = {
    position?: TransitionValue;
    rotation?: TransitionValue;
    color?: TransitionValue;
};
export declare type SkeletalAnimationValue = {
    clip: string | number;
    loop?: boolean;
    weight?: number;
    playing?: boolean;
};
export declare type SkeletalAnimationComponent = SkeletalAnimationValue[];
