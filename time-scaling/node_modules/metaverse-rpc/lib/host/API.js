const hasSymbol = typeof Symbol === 'function' && Symbol.for;
const exposedMethodSymbol = hasSymbol ? Symbol('exposedMethod') : 0xfea1;
export function exposeMethod(target, propertyKey, descriptor) {
    getExposedMethods(target).add(propertyKey);
}
export function getExposedMethods(instance) {
    const instanceAny = instance;
    instanceAny[exposedMethodSymbol] = instanceAny[exposedMethodSymbol] || new Set();
    return instanceAny[exposedMethodSymbol];
}
export function rateLimit(interval = 100) {
    return function (target, propertyKey, descriptor) {
        const originalValue = descriptor.value;
        let lastCall = performance.now();
        return Object.assign({}, descriptor, { value: function () {
                const now = performance.now();
                if (now - lastCall < interval) {
                    return Promise.reject(new Error('Rate limit exceeded'));
                }
                lastCall = now;
                return originalValue.apply(this, arguments);
            } });
    };
}
export function throttle(callLimit, interval = 100) {
    return function (target, propertyKey, descriptor) {
        const originalValue = descriptor.value;
        let initTime = performance.now();
        let calls = 0;
        return Object.assign({}, descriptor, { value: function () {
                const now = performance.now();
                if (now - initTime >= interval) {
                    calls = 0;
                    initTime = now;
                }
                if (calls >= callLimit) {
                    return Promise.reject(new Error('Throttling â€“ Maximum rate exceeded'));
                }
                calls++;
                return originalValue.apply(this, arguments);
            } });
    };
}
export class API {
    constructor(options) {
        this.options = options;
        for (let methodName of getExposedMethods(this)) {
            const theMethod = this[methodName];
            if (typeof theMethod === 'function') {
                this.options.expose(methodName, theMethod.bind(this));
            }
        }
    }
    static factory(ctor, options) {
        return new ctor(options);
    }
}
API.expose = exposeMethod;
export class SubscribableAPI extends API {
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQVBJLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2hvc3QvQVBJLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUtBLE1BQU0sU0FBUyxHQUFHLE9BQU8sTUFBTSxLQUFLLFVBQVUsSUFBSSxNQUFNLENBQUMsR0FBRyxDQUFBO0FBRTVELE1BQU0sbUJBQW1CLEdBQUcsU0FBUyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQTtBQUV4RSxNQUFNLHVCQUNKLE1BQVMsRUFDVCxXQUFvQixFQUNwQixVQUFvRDtJQUVwRCxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUE7QUFDNUMsQ0FBQztBQUVELE1BQU0sNEJBQTJDLFFBQVc7SUFDMUQsTUFBTSxXQUFXLEdBQVEsUUFBUSxDQUFBO0lBQ2pDLFdBQVcsQ0FBQyxtQkFBbUIsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLElBQUksR0FBRyxFQUFFLENBQUE7SUFDaEYsT0FBTyxXQUFXLENBQUMsbUJBQW1CLENBQUMsQ0FBQTtBQUN6QyxDQUFDO0FBRUQsTUFBTSxvQkFBdUIsV0FBbUIsR0FBRztJQUNqRCxPQUFPLFVBQ0wsTUFBUyxFQUNULFdBQW1CLEVBQ25CLFVBQTRFO1FBRTVFLE1BQU0sYUFBYSxHQUFHLFVBQVUsQ0FBQyxLQUFpQixDQUFBO1FBQ2xELElBQUksUUFBUSxHQUFXLFdBQVcsQ0FBQyxHQUFHLEVBQUUsQ0FBQTtRQUV4Qyx5QkFDSyxVQUFVLElBQ2IsS0FBSyxFQUFFO2dCQUNMLE1BQU0sR0FBRyxHQUFHLFdBQVcsQ0FBQyxHQUFHLEVBQUUsQ0FBQTtnQkFFN0IsSUFBSSxHQUFHLEdBQUcsUUFBUSxHQUFHLFFBQVEsRUFBRTtvQkFDN0IsT0FBTyxPQUFPLENBQUMsTUFBTSxDQUFDLElBQUksS0FBSyxDQUFDLHFCQUFxQixDQUFDLENBQUMsQ0FBQTtpQkFDeEQ7Z0JBRUQsUUFBUSxHQUFHLEdBQUcsQ0FBQTtnQkFDZCxPQUFPLGFBQWEsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFBO1lBQzdDLENBQUMsSUFDRjtJQUNILENBQUMsQ0FBQTtBQUNILENBQUM7QUFFRCxNQUFNLG1CQUFzQixTQUFpQixFQUFFLFdBQW1CLEdBQUc7SUFDbkUsT0FBTyxVQUNMLE1BQVMsRUFDVCxXQUFtQixFQUNuQixVQUE0RTtRQUU1RSxNQUFNLGFBQWEsR0FBRyxVQUFVLENBQUMsS0FBaUIsQ0FBQTtRQUNsRCxJQUFJLFFBQVEsR0FBVyxXQUFXLENBQUMsR0FBRyxFQUFFLENBQUE7UUFDeEMsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFBO1FBRWIseUJBQ0ssVUFBVSxJQUNiLEtBQUssRUFBRTtnQkFDTCxNQUFNLEdBQUcsR0FBRyxXQUFXLENBQUMsR0FBRyxFQUFFLENBQUE7Z0JBRTdCLElBQUksR0FBRyxHQUFHLFFBQVEsSUFBSSxRQUFRLEVBQUU7b0JBQzlCLEtBQUssR0FBRyxDQUFDLENBQUE7b0JBQ1QsUUFBUSxHQUFHLEdBQUcsQ0FBQTtpQkFDZjtnQkFFRCxJQUFJLEtBQUssSUFBSSxTQUFTLEVBQUU7b0JBQ3RCLE9BQU8sT0FBTyxDQUFDLE1BQU0sQ0FBQyxJQUFJLEtBQUssQ0FBQyxvQ0FBb0MsQ0FBQyxDQUFDLENBQUE7aUJBQ3ZFO2dCQUVELEtBQUssRUFBRSxDQUFBO2dCQUVQLE9BQU8sYUFBYSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUE7WUFDN0MsQ0FBQyxJQUNGO0lBQ0gsQ0FBQyxDQUFBO0FBQ0gsQ0FBQztBQWdERCxNQUFNO0lBR0osWUFBc0IsT0FBbUI7UUFBbkIsWUFBTyxHQUFQLE9BQU8sQ0FBWTtRQUN2QyxLQUFLLElBQUksVUFBVSxJQUFJLGlCQUFpQixDQUFDLElBQUksQ0FBQyxFQUFFO1lBQzlDLE1BQU0sU0FBUyxHQUFRLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQTtZQUN2QyxJQUFJLE9BQU8sU0FBUyxLQUFLLFVBQVUsRUFBRTtnQkFDbkMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsVUFBVSxFQUFFLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQTthQUN0RDtTQUNGO0lBQ0gsQ0FBQztJQUVELE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBbUIsRUFBRSxPQUFtQjtRQUNyRCxPQUFPLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFBO0lBQzFCLENBQUM7O0FBYk0sVUFBTSxHQUFHLFlBQVksQ0FBQTtBQWdCOUIsTUFBTSxzQkFBZ0MsU0FBUSxHQUFHO0NBRWhEIiwic291cmNlc0NvbnRlbnQiOlsiLy8gaHR0cDovL2dhbWVwcm9ncmFtbWluZ3BhdHRlcm5zLmNvbS9jb21wb25lbnQuaHRtbFxuXG4vLyBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcbmNvbnN0IGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvclxuXG5jb25zdCBleHBvc2VkTWV0aG9kU3ltYm9sID0gaGFzU3ltYm9sID8gU3ltYm9sKCdleHBvc2VkTWV0aG9kJykgOiAweGZlYTFcblxuZXhwb3J0IGZ1bmN0aW9uIGV4cG9zZU1ldGhvZDxUIGV4dGVuZHMgQVBJPihcbiAgdGFyZ2V0OiBULFxuICBwcm9wZXJ0eUtleToga2V5b2YgVCxcbiAgZGVzY3JpcHRvcjogVHlwZWRQcm9wZXJ0eURlc2NyaXB0b3I8RXhwb3NhYmxlTWV0aG9kPlxuKSB7XG4gIGdldEV4cG9zZWRNZXRob2RzKHRhcmdldCkuYWRkKHByb3BlcnR5S2V5KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXhwb3NlZE1ldGhvZHM8VCBleHRlbmRzIEFQST4oaW5zdGFuY2U6IFQpOiBTZXQ8a2V5b2YgVD4ge1xuICBjb25zdCBpbnN0YW5jZUFueTogYW55ID0gaW5zdGFuY2VcbiAgaW5zdGFuY2VBbnlbZXhwb3NlZE1ldGhvZFN5bWJvbF0gPSBpbnN0YW5jZUFueVtleHBvc2VkTWV0aG9kU3ltYm9sXSB8fCBuZXcgU2V0KClcbiAgcmV0dXJuIGluc3RhbmNlQW55W2V4cG9zZWRNZXRob2RTeW1ib2xdXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByYXRlTGltaXQ8VD4oaW50ZXJ2YWw6IG51bWJlciA9IDEwMCkge1xuICByZXR1cm4gZnVuY3Rpb24oXG4gICAgdGFyZ2V0OiBULFxuICAgIHByb3BlcnR5S2V5OiBzdHJpbmcsXG4gICAgZGVzY3JpcHRvcjogVHlwZWRQcm9wZXJ0eURlc2NyaXB0b3I8KC4uLmFyZ3M6IGFueVtdKSA9PiBQcm9taXNlPGFueSB8IHZvaWQ+PlxuICApIHtcbiAgICBjb25zdCBvcmlnaW5hbFZhbHVlID0gZGVzY3JpcHRvci52YWx1ZSBhcyBGdW5jdGlvblxuICAgIGxldCBsYXN0Q2FsbDogbnVtYmVyID0gcGVyZm9ybWFuY2Uubm93KClcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5kZXNjcmlwdG9yLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKHRoaXM6IFQpIHtcbiAgICAgICAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KClcblxuICAgICAgICBpZiAobm93IC0gbGFzdENhbGwgPCBpbnRlcnZhbCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1JhdGUgbGltaXQgZXhjZWVkZWQnKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RDYWxsID0gbm93XG4gICAgICAgIHJldHVybiBvcmlnaW5hbFZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRocm90dGxlPFQ+KGNhbGxMaW1pdDogbnVtYmVyLCBpbnRlcnZhbDogbnVtYmVyID0gMTAwKSB7XG4gIHJldHVybiBmdW5jdGlvbihcbiAgICB0YXJnZXQ6IFQsXG4gICAgcHJvcGVydHlLZXk6IHN0cmluZyxcbiAgICBkZXNjcmlwdG9yOiBUeXBlZFByb3BlcnR5RGVzY3JpcHRvcjwoLi4uYXJnczogYW55W10pID0+IFByb21pc2U8YW55IHwgdm9pZD4+XG4gICkge1xuICAgIGNvbnN0IG9yaWdpbmFsVmFsdWUgPSBkZXNjcmlwdG9yLnZhbHVlIGFzIEZ1bmN0aW9uXG4gICAgbGV0IGluaXRUaW1lOiBudW1iZXIgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgIGxldCBjYWxscyA9IDBcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5kZXNjcmlwdG9yLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKHRoaXM6IFQpIHtcbiAgICAgICAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KClcblxuICAgICAgICBpZiAobm93IC0gaW5pdFRpbWUgPj0gaW50ZXJ2YWwpIHtcbiAgICAgICAgICBjYWxscyA9IDBcbiAgICAgICAgICBpbml0VGltZSA9IG5vd1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNhbGxzID49IGNhbGxMaW1pdCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1Rocm90dGxpbmcg4oCTIE1heGltdW0gcmF0ZSBleGNlZWRlZCcpKVxuICAgICAgICB9XG5cbiAgICAgICAgY2FsbHMrK1xuXG4gICAgICAgIHJldHVybiBvcmlnaW5hbFZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgQVBJT3B0aW9ucyA9IHtcbiAgYXBpTmFtZTogc3RyaW5nXG4gIHN5c3RlbTogYW55XG4gIG9uKGV2ZW50OiBzdHJpbmcsIGhhbmRsZXI6IDxBLCBPIGV4dGVuZHMgb2JqZWN0PihwYXJhbXM6IEFycmF5PEE+IHwgTykgPT4gdm9pZCk6IHZvaWRcbiAgbm90aWZ5KGV2ZW50OiBzdHJpbmcsIHBhcmFtcz86IE9iamVjdCB8IEFycmF5PGFueT4pOiB2b2lkXG4gIGV4cG9zZShldmVudDogc3RyaW5nLCBoYW5kbGVyOiA8QSwgTyBleHRlbmRzIG9iamVjdD4ocGFyYW1zOiBBcnJheTxBPiB8IE8pID0+IFByb21pc2U8YW55Pik6IHZvaWRcbiAgZ2V0QVBJSW5zdGFuY2U8WD4oY29tcG9uZW50OiB7IG5ldyAob3B0aW9uczogQVBJT3B0aW9ucyk6IFggfSk6IFhcbiAgZ2V0QVBJSW5zdGFuY2UobmFtZTogc3RyaW5nKTogQVBJIHwgbnVsbFxufVxuXG5leHBvcnQgdHlwZSBBUElDbGFzczxUPiA9IHtcbiAgbmV3IChvcHRpb25zOiBBUElPcHRpb25zKTogVFxufVxuXG5leHBvcnQgdHlwZSBFeHBvc2FibGVNZXRob2QgPSAoLi4uYXJnczogYW55W10pID0+IFByb21pc2U8YW55PlxuXG4vLyB3ZSB1c2UgYW4gaW50ZXJmYWNlIGhlcmUgYmVjYXVzZSBpdCBpcyBtZXJnYWJsZSB3aXRoIHRoZSBjbGFzc1xuZXhwb3J0IGludGVyZmFjZSBBUEkge1xuICBhcGlEaWRNb3VudD8oKTogUHJvbWlzZTx2b2lkPiB8IHZvaWRcbiAgYXBpV2lsbFVubW91bnQ/KCk6IFByb21pc2U8dm9pZD4gfCB2b2lkXG59XG5cbi8qKlxuICogVGhpcyBwYXR0ZXJuIGJlYXJzIHJlc2VtYmxhbmNlIHRvIHRoZSBHYW5nIG9mIEZvdXLigJlzIFN0cmF0ZWd5IHBhdHRlcm4uXG4gKiBCb3RoIHBhdHRlcm5zIGFyZSBhYm91dCB0YWtpbmcgcGFydCBvZiBhbiBvYmplY3TigJlzIGJlaGF2aW9yIGFuZCBkZWxlZ2F0aW5nXG4gKiBpdCB0byBhIHNlcGFyYXRlIHN1Ym9yZGluYXRlIG9iamVjdC4gVGhlIGRpZmZlcmVuY2UgaXMgdGhhdCB3aXRoIHRoZSBTdHJhdGVneVxuICogcGF0dGVybiwgdGhlIHNlcGFyYXRlIOKAnHN0cmF0ZWd54oCdIG9iamVjdCBpcyB1c3VhbGx5IHN0YXRlbGVzc+KAlGl0IGVuY2Fwc3VsYXRlc1xuICogYW4gYWxnb3JpdGhtLCBidXQgbm8gZGF0YS4gSXQgZGVmaW5lcyBob3cgYW4gb2JqZWN0IGJlaGF2ZXMsIGJ1dCBub3Qgd2hhdCBpdCBpcy5cbiAqXG4gKiBodHRwOi8vd2lraS5jMi5jb20vP1N0cmF0ZWd5UGF0dGVyblxuICpcbiAqIENvbXBvbmVudHMgYXJlIGEgYml0IG1vcmUgc2VsZi1pbXBvcnRhbnQuIFRoZXkgb2Z0ZW4gaG9sZCBzdGF0ZSB0aGF0IGRlc2NyaWJlc1xuICogdGhlIG9iamVjdCBhbmQgaGVscHMgZGVmaW5lIGl0cyBhY3R1YWwgaWRlbnRpdHkuIEhvd2V2ZXIsIHRoZSBsaW5lIG1heSBibHVyLlxuICogWW91IG1heSBoYXZlIHNvbWUgY29tcG9uZW50cyB0aGF0IGRvbuKAmXQgbmVlZCBhbnkgbG9jYWwgc3RhdGUuIEluIHRoYXQgY2FzZSxcbiAqIHlvdeKAmXJlIGZyZWUgdG8gdXNlIHRoZSBzYW1lIGNvbXBvbmVudCBpbnN0YW5jZSBhY3Jvc3MgbXVsdGlwbGUgY29udGFpbmVyIG9iamVjdHMuXG4gKiBBdCB0aGF0IHBvaW50LCBpdCByZWFsbHkgaXMgYmVoYXZpbmcgbW9yZSBha2luIHRvIGEgc3RyYXRlZ3kuXG4gKlxuICogQ29tcG9uZW50cyBhcmUgbG9jYXRlZCB2aWEgc2VydmljZSBsb2NhdG9ycyBtYW5hZ2VkIGJ5IHRoZSBDb21wb25lbnRTeXN0ZW1cbiAqXG4gKiBBIENvbXBvbmVudHMgY2xhc3MgZGVmaW5lcyBhbiBhYnN0cmFjdCBpbnRlcmZhY2UgdG8gYSBzZXQgb2Ygb3BlcmF0aW9ucy5cbiAqIFRoYXQgaW50ZXJmYWNlIGlzIGV4cG9zZWQgdmlhIEBleHBvc2VNZXRob2QgZGVjb3JhdG9yLiBBIGNvbmNyZXRlIHNlcnZpY2VcbiAqIHByb3ZpZGVyIGltcGxlbWVudHMgdGhpcyBpbnRlcmZhY2UuIEEgc2VwYXJhdGUgc2VydmljZSBsb2NhdG9yIChDb21wb25lbnRTeXN0ZW0pXG4gKiBwcm92aWRlcyBhY2Nlc3MgdG8gdGhlIHNlcnZpY2UgYnkgZmluZGluZyBhbiBhcHByb3ByaWF0ZSBwcm92aWRlciB3aGlsZSBoaWRpbmdcbiAqIGJvdGggdGhlIHByb3ZpZGVy4oCZcyBjb25jcmV0ZSB0eXBlIGFuZCBpbXBsZW1lbnRhdGlvbiBhbmQgdGhlIHByb2Nlc3MgdXNlZCB0b1xuICogbG9jYXRlIGl0LlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQVBJIHtcbiAgc3RhdGljIGV4cG9zZSA9IGV4cG9zZU1ldGhvZFxuXG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBvcHRpb25zOiBBUElPcHRpb25zKSB7XG4gICAgZm9yIChsZXQgbWV0aG9kTmFtZSBvZiBnZXRFeHBvc2VkTWV0aG9kcyh0aGlzKSkge1xuICAgICAgY29uc3QgdGhlTWV0aG9kOiBhbnkgPSB0aGlzW21ldGhvZE5hbWVdXG4gICAgICBpZiAodHlwZW9mIHRoZU1ldGhvZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLm9wdGlvbnMuZXhwb3NlKG1ldGhvZE5hbWUsIHRoZU1ldGhvZC5iaW5kKHRoaXMpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBmYWN0b3J5KGN0b3I6IEFQSUNsYXNzPEFQST4sIG9wdGlvbnM6IEFQSU9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IGN0b3Iob3B0aW9ucylcbiAgfVxufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU3Vic2NyaWJhYmxlQVBJIGV4dGVuZHMgQVBJIHtcbiAgYWJzdHJhY3QgYXN5bmMgc3Vic2NyaWJlKGV2ZW50OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVN1YnNjcmliYWJsZUFQSSB7XG4gIHN1YnNjcmliZShldmVudDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPlxuICB1bnN1YnNjcmliZShldmVudDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPlxuICBvblN1YnNjcmliZWRFdmVudChmbjogKGRhdGE6IGFueSkgPT4gdm9pZCk6IHZvaWRcbn1cbiJdfQ==